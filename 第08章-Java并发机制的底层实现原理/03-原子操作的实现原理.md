# 原子操作的实现原理

## 处理器对原子操作的实现

1. 通过总线锁保证原子性

总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

2. 使用缓存锁保证原子性

指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

## java原子操作的实现

### 使用循环CAS实现原子操作

JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。

- CAS三大问题：

（1）ABA问题

如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。

ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，JDK1.5的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查**当前标志是否等于预期标志**，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

（2）循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

（3）只能保证一个共享变量的原子操作

对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。

两个方案：

一是：就是把多个共享变量合并成一个共享变量来操作
二是：实用jdk的AtomicReference类来保证引用对象之间的原子性，把多个变量放在一个对象里来进行CAS操作

### 使用锁机制实现原子操作

锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。

JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。

除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。
