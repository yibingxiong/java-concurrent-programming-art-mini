# 线程池原理

## 线程池处理流程

![线程池处理流程](images/线程池任务执行流程.png)


## 大雄看源码的感受

我首先是看了《java并发编程艺术》的原理讲解，发现还是比较容易理解的，然后一看源码，我的天，怎么那么多位运算，看的头都大了，所以不想看了。然后就去网上找资料，发现竟然有人把那些一个一个位运算的值转成了10进制（这没有错，但是在我看来，作为一篇文章的，这些细枝末节无关紧要的东西最好不要有，会分散注意力）。看得依然头疼，然后鼓起勇气把ThreadPollExcutor类从上到下看了下，也没仔细看，发现竟然豁然开朗了。

## 原理

### Worker

Worker被装在一个HashSet（workers）里边， 他是用来执行任务的，他们的职责就是不断的从workQueue里边取任务，然后执行。当workQueue里边拿不到任务，或者线程池达到特定状态，worker就会从workers里边移走。

下边是Worker源码，移除了非关键的东西

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    private static final long serialVersionUID = 6138294804551838833L;

    // 标识这个任务是在哪个线程运行
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    // 完成了几个任务
    volatile long completedTasks;

    Worker(Runnable firstTask) {
        // 阻止中断，知道runWorker
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        // 直接用你提供的线程工厂搞个线程出来
        this.thread = getThreadFactory().newThread(this);
    }

    // 调用ThreadPoolExecutor里边的runWorker方法
    public void run() {
        runWorker(this);
    }

    // 以下这些是AQS相关的东西

    // 0代表没有加锁
    // 1代表加锁了
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```

Worker实现了Runnable接口，所以他是个任务，有run方法；同时有继承了AQS，所以他也是一把锁。


下边是提交任务的过程

提交任务有submit和execute, submit就是首先将Callable或者Runnable包装成FutureTask，然后调用execute, 所以核心是分析execute

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    // 这个c里边有两个信息，一个是现在有多少worker, 另一个是现在线程池的状态是啥
    // workerCountOf方法就是从里边提取 worker的数量的
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) { // 当前worker的数量比需要的核心线程数少
        // 加worker去执行,加成功就完事了，也就是说只要worker比核心线程数少，就会创建worker
        // 不管现在核心线程是否在工作，也不管workQueue是不是满的
        // addWorker的第二个参数表示是不是要加核心线程（或者叫核心worker)
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 当前worker达到或超过了核心线程数，或者加worker失败了，才会走下边的流程
    // worker已经比核心线程数多了

    // 如果 线程池没有shutdown的话 
    // 就尝试将任务加到workQueue里边，工作队列入队成功的话
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            // 再次检查状态如果线程池要停了，那么就拒绝任务，并且把worker从工作队列扔掉
            reject(command);
        else if (workerCountOf(recheck) == 0)
            // 如果没有worker的话(说明没加进去，这种场景我没想到是什么情况)，加一个worker
            addWorker(null, false);
        // 其他情况，丢到工作队列就不用管了，等着worker去处理
    }
    // 如果队列满了加失败了，或者线程池状态不满足了，就尝试加普通worker(非核心线程)
    else if (!addWorker(command, false))
        // 加失败了就拒绝任务
        // 失败一方面可能是worker数量已经达到你的给的maximumPoolSize
        // 另一方面，可能是检查到线程池的状态不对了
        reject(command);
}
```
可以发现execute方法就是完成了上边说的“线程池处理流程”这个图里描述的过程。 大雄看到这里还有几个疑问，一个是Woker是如何创建并加入workers的，一个是worker是如何启动的，再就是worker是如何运行的

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 做一些校验，线程池的状态要满足一定条件
        // 而且得提交任务过来，在就是workQueue已经满了
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
                firstTask == null &&
                ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            // 看你是要创建核心worker还是普通worker
            // 核心看超没超过corePoolSize, 普通看超没超过maximumPoolSize
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
            // 增加worker数量失败就在来
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                // 中途线程池状态发生变化了
                continue retry;
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // worker就是这么创建的
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // 加worker是要加全局锁的
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // worker是在这里启动的
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```
这段代码解决了 Woker是如何创建并加入workers的以及worker是如何启动的的问题。

addWorker做的核心工作就是，创建worker, 启动worker, 在创建之前还会做一些校验。调用了worker里边线程的start后就要等待cpu调度执行worker的run方法了。

```java
public void run() {
    runWorker(this);
}

final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        // task是创建worker带进去的任务，会先执行他，然后从workQueue里边取
        // 如果没有的话跳出去
        while (task != null || (task = getTask()) != null) {
            w.lock();   // 首先加锁，如果不加锁，可能几个线程提交的任务同时进来了，会导致一些共享状态出问题

            // 做一些状态的校验
            if ((runStateAtLeast(ctl.get(), STOP) ||
                    (Thread.interrupted() &&
                    runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                // 执行任务前调用一下beforeExecute， 默认是空的
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    // 这个跟我们平时理解的Runnable还不一样，可以体会下，他这个run就是一个普通的方法
                    // 他这个直接调run是要执行任务，线程的start只是把worker里边的任务跑起来了
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 执行完了调一下，里边可以拿到异常
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 从while跳出来表明没有任务可以执行了
        processWorkerExit(w, completedAbruptly);
    }
}
```

这个也比较容易，就是不断的从workQueue取任务，执行，直到没任务了跳出来。接下来就是worker如何被销毁的问题了


Worker是ThreadPoolExecutor的内部类，你可以把它想象成一个工人，这个工人在进入工作岗位的时候会携带一个任务，一进入工作岗位他就开始工作了，他首先是处理完自己的工作，然后就一直去任务池找任务，找到任务就把自己锁到一个房间里，任务，一直找任务，直到没有拿不到任务了，他就被裁了。被裁之后，如果他是核心工人，那么工厂会招聘另一个工人，不携带任务上岗；如果不是核心工人，裁了就裁了。



